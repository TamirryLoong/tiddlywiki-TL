{
    "tiddlers": {
        "$:/core/ui/ControlPanel/Saving/Snapshot": {
            "text": "| <$link to=\"$:/config/Snapshot/BackupLocation\">Backup Location</$link>|<$edit-text tiddler=\"$:/config/Snapshot/BackupLocation\" default=\"\" tag=\"input\"/>|\n| <$link to=\"$:/config/Snapshot/SuffixFormat\">Suffix Format</$link>|<$edit-text tiddler=\"$:/config/Snapshot/SuffixFormat\" default=\"\" tag=\"input\"/>|\n\n",
            "title": "$:/core/ui/ControlPanel/Saving/Snapshot",
            "tags": "$:/tags/ControlPanel/Saving",
            "modified": "20180824070405084",
            "created": "20180824055743178",
            "caption": "Snapshot"
        },
        "$:/core/modules/savers/tiddlyfoxBackup.js": {
            "text": "/*\\\ntitle: $:/core/modules/savers/tiddlyBackup.js\ntype: application/javascript\nmodule-type: saver\n\nHandles saving changes via the TiddlyFox file extension\n\n\\*/\n(function() {\n\n    /*jslint node: true, browser: true */\n    /*global $tw: false, netscape: false, Components: false */\n    \"use strict\";\n\n    var TiddlyBackup = function(wiki) {};\n\n    function cleanPath(pathname) {\n        // Replace file://localhost/ with file:///\n        if (pathname.indexOf(\"file://localhost/\") === 0) {\n            pathname = \"file://\" + pathname.substr(16);\n        }\n        // Windows path file:///x:/blah/blah --> x:\\blah\\blah\n        if (/^file\\:\\/\\/\\/[A-Z]\\:\\//i.test(pathname)) {\n            // Remove the leading slash and convert slashes to backslashes\n            pathname = pathname.substr(8).replace(/\\//g, \"\\\\\");\n            // Firefox Windows network path file://///server/share/blah/blah --> //server/share/blah/blah\n        } else if (pathname.indexOf(\"file://///\") === 0) {\n            pathname = \"\\\\\\\\\" + unescape(pathname.substr(10)).replace(/\\//g, \"\\\\\");\n            // Mac/Unix local path file:///path/path --> /path/path\n        } else if (pathname.indexOf(\"file:///\") === 0) {\n            pathname = unescape(pathname.substr(7));\n            // Mac/Unix local path file:/path/path --> /path/path\n        } else if (pathname.indexOf(\"file:/\") === 0) {\n            pathname = unescape(pathname.substr(5));\n            // Otherwise Windows networth path file://server/share/path/path --> \\\\server\\share\\path\\path\n        } else {\n            pathname = \"\\\\\\\\\" + unescape(pathname.substr(7)).replace(new RegExp(\"/\", \"g\"), \"\\\\\");\n        }\n        return pathname;\n    }\n\n    function resolveRelativePath(base, relative) {\n        var stack = base.split(\"/\"),\n            parts = relative.split(\"/\");\n        stack.pop(); // remove current file name (or empty string)\n        // (omit if \"base\" is the current folder without trailing slash)\n        for (var i = 0; i < parts.length; i++) {\n            if (parts[i] == \".\")\n                continue;\n            if (parts[i] == \"..\")\n                stack.pop();\n            else\n                stack.push(parts[i]);\n        }\n        return stack.join(\"/\");\n    }\n\n    TiddlyBackup.prototype.save = function(text, method, callback) {\n        var messageBox = document.getElementById(\"tiddlyfox-message-box\");\n        if (messageBox) {\n            // Get the pathname of this document\n            var windowlocation = document.location.toString().split(\"#\")[0];\n            var backuplocation = $tw.wiki.getTiddlerText(\"$:/config/Snapshot/BackupLocation\");\n            var filename = window.location.pathname.split(\"/\").slice(-1)[0];\n            var pathname;\n            // Check if user has specified a backup location\n            if (typeof backuplocation !== \"undefined\" && backuplocation !== \"\") {\n                // Check if the back up location ends in a \"/\" and if NOT, add a \"/\"\n                if (backuplocation.substr(-1) != '/') backuplocation += '/';\n                if (backuplocation.charAt(0) == \".\") {\n                    // resolve the relative path\n                    backuplocation = resolveRelativePath(cleanPath(windowlocation), backuplocation);\n                }\n                pathname = backuplocation + filename;\n            } else {\n                pathname = cleanPath(windowlocation);\n\n            }\n            // Create the message element and put it in the message box\n            var message = document.createElement(\"div\");\n\n            var df = $tw.utils.formatDateString(new Date(), $tw.wiki.getTiddlerText(\"$:/config/Snapshot/SuffixFormat\") || \"0DD-0MM-YYYY--0hh-0mm-0ss\");\n            pathname = pathname.substring(0, pathname.lastIndexOf(\".\")) + '--' + df + pathname.substring(pathname.lastIndexOf(\".\"));\n            message.setAttribute(\"data-tiddlyfox-path\", decodeURIComponent(pathname));\n            message.setAttribute(\"data-tiddlyfox-content\", text);\n            messageBox.appendChild(message);\n            // Add an event handler for when the file has been saved\n            message.addEventListener(\"tiddlyfox-have-saved-file\", function(event) {\n                callback(null);\n            }, false);\n            // Create and dispatch the custom event to the extension\n            var event = document.createEvent(\"Events\");\n            event.initEvent(\"tiddlyfox-save-file\", true, false);\n            message.dispatchEvent(event);\n            return true;\n        } else {\n            return false;\n        }\n    };\n\n    /*\n    Information about this saver\n    */\n    TiddlyBackup.prototype.info = {\n        name: \"tiddlyfox\",\n        priority: 1500,\n        capabilities: [\"backup\"]\n    };\n\n    /*\n    Static method that returns true if this saver is capable of working\n    */\n    exports.canSave = function(wiki) {\n        return true;\n    };\n\n    /*\n    Create an instance of this saver\n    */\n    exports.create = function(wiki) {\n        return new TiddlyBackup(wiki);\n    };\n\n})();",
            "type": "application/javascript",
            "title": "$:/core/modules/savers/tiddlyfoxBackup.js",
            "tags": "",
            "module-type": "saver",
            "modified": "20180924034247998",
            "created": "20180820110234866"
        },
        "$:/core/modules/saver-handler.js": {
            "text": "/*\\\ntitle: $:/core/modules/saver-handler.js\ntype: application/javascript\nmodule-type: global\n\nThe saver handler tracks changes to the store and handles saving the entire wiki via saver modules.\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n/*\nInstantiate the saver handler with the following options:\nwiki: wiki to be synced\ndirtyTracking: true if dirty tracking should be performed\n*/\nfunction SaverHandler(options) {\n\tvar self = this;\n\tthis.wiki = options.wiki;\n\tthis.dirtyTracking = options.dirtyTracking;\n\tthis.pendingAutoSave = false;\n\t// Make a logger\n\tthis.logger = new $tw.utils.Logger(\"saver-handler\");\n\t// Initialise our savers\n\tif($tw.browser) {\n\t\tthis.initSavers();\n\t}\n\t// Only do dirty tracking if required\n\tif($tw.browser && this.dirtyTracking) {\n\t\t// Compile the dirty tiddler filter\n\t\tthis.filterFn = this.wiki.compileFilter(this.wiki.getTiddlerText(this.titleSyncFilter));\n\t\t// Count of changes that have not yet been saved\n\t\tthis.numChanges = 0;\n\t\t// Listen out for changes to tiddlers\n\t\tthis.wiki.addEventListener(\"change\",function(changes) {\n\t\t\t// Filter the changes so that we only count changes to tiddlers that we care about\n\t\t\tvar filteredChanges = self.filterFn.call(self.wiki,function(iterator) {\n\t\t\t\t$tw.utils.each(changes,function(change,title) {\n\t\t\t\t\tvar tiddler = self.wiki.getTiddler(title);\n\t\t\t\t\titerator(tiddler,title);\n\t\t\t\t});\n\t\t\t});\n\t\t\t// Adjust the number of changes\n\t\t\tself.numChanges += filteredChanges.length;\n\t\t\tself.updateDirtyStatus();\n\t\t\t// Do any autosave if one is pending and there's no more change events\n\t\t\tif(self.pendingAutoSave && self.wiki.getSizeOfTiddlerEventQueue() === 0) {\n\t\t\t\t// Check if we're dirty\n\t\t\t\tif(self.numChanges > 0) {\n\t\t\t\t\tself.saveWiki({\n\t\t\t\t\t\tmethod: \"autosave\",\n\t\t\t\t\t\tdownloadType: \"text/plain\"\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tself.pendingAutoSave = false;\n\t\t\t}\n\t\t});\n\t\t// Listen for the autosave event\n\t\t$tw.rootWidget.addEventListener(\"tm-auto-save-wiki\",function(event) {\n\t\t\t// Do the autosave unless there are outstanding tiddler change events\n\t\t\tif(self.wiki.getSizeOfTiddlerEventQueue() === 0) {\n\t\t\t\t// Check if we're dirty\n\t\t\t\tif(self.numChanges > 0) {\n\t\t\t\t\tself.saveWiki({\n\t\t\t\t\t\tmethod: \"autosave\",\n\t\t\t\t\t\tdownloadType: \"text/plain\"\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Otherwise put ourselves in the \"pending autosave\" state and wait for the change event before we do the autosave\n\t\t\t\tself.pendingAutoSave = true;\n\t\t\t}\n\t\t});\n\t\t// Set up our beforeunload handler\n\t\t$tw.addUnloadTask(function(event) {\n\t\t\tvar confirmationMessage;\n\t\t\tif(self.isDirty()) {\n\t\t\t\tconfirmationMessage = $tw.language.getString(\"UnsavedChangesWarning\");\n\t\t\t\tevent.returnValue = confirmationMessage; // Gecko\n\t\t\t}\n\t\t\treturn confirmationMessage;\n\t\t});\n\t}\n\t// Install the save action handlers\n\tif($tw.browser) {\n\t\t$tw.rootWidget.addEventListener(\"tm-save-wiki\",function(event) {\n\t\t\tself.saveWiki({\n\t\t\t\ttemplate: event.param,\n\t\t\t\tdownloadType: \"text/plain\",\n\t\t\t\tvariables: event.paramObject\n\t\t\t});\n\t\t});\n\t\t$tw.rootWidget.addEventListener(\"tm-download-file\",function(event) {\n\t\t\tself.saveWiki({\n\t\t\t\tmethod: \"download\",\n\t\t\t\ttemplate: event.param,\n\t\t\t\tdownloadType: \"text/plain\",\n\t\t\t\tvariables: event.paramObject\n\t\t\t});\n\t\t});\n              $tw.rootWidget.addEventListener(\"tm-backup-wiki\",function(event) {\n\t\t\tself.saveWiki({\n\t\t\t\tmethod: \"backup\",\n\t\t\t\ttemplate: event.param,\n\t\t\t\tdownloadType: \"text/plain\",\n\t\t\t\tvariables: event.paramObject\n\t\t\t});\n\t\t});\n\t}\n}\n\nSaverHandler.prototype.titleSyncFilter = \"$:/config/SaverFilter\";\nSaverHandler.prototype.titleAutoSave = \"$:/config/AutoSave\";\nSaverHandler.prototype.titleSavedNotification = \"$:/language/Notifications/Save/Done\";\n\n/*\nSelect the appropriate saver modules and set them up\n*/\nSaverHandler.prototype.initSavers = function(moduleType) {\n\tmoduleType = moduleType || \"saver\";\n\t// Instantiate the available savers\n\tthis.savers = [];\n\tvar self = this;\n\t$tw.modules.forEachModuleOfType(moduleType,function(title,module) {\n\t\tif(module.canSave(self)) {\n\t\t\tself.savers.push(module.create(self.wiki));\n\t\t}\n\t});\n\t// Sort the savers into priority order\n\tthis.savers.sort(function(a,b) {\n\t\tif(a.info.priority < b.info.priority) {\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tif(a.info.priority > b.info.priority) {\n\t\t\t\treturn +1;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t});\n};\n\n/*\nSave the wiki contents. Options are:\n\tmethod: \"save\", \"autosave\" or \"download\"\n\ttemplate: the tiddler containing the template to save\n\tdownloadType: the content type for the saved file\n*/\nSaverHandler.prototype.saveWiki = function(options) {\n\toptions = options || {};\n\tvar self = this,\n\t\tmethod = options.method || \"save\",\n\t\tvariables = options.variables || {},\n\t\ttemplate = options.template || \"$:/core/save/all\",\n\t\tdownloadType = options.downloadType || \"text/plain\",\n\t\ttext = this.wiki.renderTiddler(downloadType,template,options),\n\t\tcallback = function(err) {\n\t\t\tif(err) {\n\t\t\t\talert($tw.language.getString(\"Error/WhileSaving\") + \":\\n\\n\" + err);\n\t\t\t} else {\n\t\t\t\t// Clear the task queue if we're saving (rather than downloading)\n\t\t\t\tif(method !== \"download\") {\n\t\t\t\t\tself.numChanges = 0;\n\t\t\t\t\tself.updateDirtyStatus();\n\t\t\t\t}\n\t\t\t\t$tw.notifier.display(self.titleSavedNotification);\n\t\t\t\tif(options.callback) {\n\t\t\t\t\toptions.callback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t// Ignore autosave if disabled\n\tif(method === \"autosave\" && this.wiki.getTiddlerText(this.titleAutoSave,\"yes\") !== \"yes\") {\n\t\treturn false;\n\t}\n\t// Call the highest priority saver that supports this method\n\tfor(var t=this.savers.length-1; t>=0; t--) {\n\t\tvar saver = this.savers[t];\n\t\tif(saver.info.capabilities.indexOf(method) !== -1 && saver.save(text,method,callback,{variables: {filename: variables.filename}})) {\n\t\t\tthis.logger.log(\"Saving wiki with method\",method,\"through saver\",saver.info.name);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n};\n\n/*\nChecks whether the wiki is dirty (ie the window shouldn't be closed)\n*/\nSaverHandler.prototype.isDirty = function() {\n\treturn this.numChanges > 0;\n};\n\n/*\nUpdate the document body with the class \"tc-dirty\" if the wiki has unsaved/unsynced changes\n*/\nSaverHandler.prototype.updateDirtyStatus = function() {\n\tif($tw.browser) {\n\t\t$tw.utils.toggleClass(document.body,\"tc-dirty\",this.isDirty());\n\t}\n};\n\nexports.SaverHandler = SaverHandler;\n\n})();\n",
            "type": "application/javascript",
            "title": "$:/core/modules/saver-handler.js",
            "revision": "0",
            "module-type": "global",
            "modified": "20180824092010979",
            "created": "20180820104549261",
            "bag": "default"
        },
        "$:/plugins/tesseract/snapshot/readme": {
            "created": "20180824091715150",
            "text": "Provides a new message ''tm-backup-wiki'' which can be triggered by button widget/any message triggering widget. Once triggered, it will save a snapshot of the wiki with a timestamp in the format `0DD-0MM-YYYY--0hh-0mm-0ss` to the same location as the original file. The default location and timestamp format can be changed under Control Panel>Saving>Snapshot. Timestamps respect the format of `now` macro. \n\nEg:\n\n```\n<$button message=\"tm-backup-wiki\"> Back me up </$button>\n```\n\nAnd my wife hates me for it.",
            "title": "$:/plugins/tesseract/snapshot/readme",
            "tags": "",
            "modified": "20180924034613226"
        }
    }
}